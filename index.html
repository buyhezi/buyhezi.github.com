<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="UTF-8">
    <title>非您生活</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/styles.css">
    <style>
    pre {
        background-color: #D9F5E8;
        padding: 10px 10px;
        color: #600EAB;
    }
    
    span {
        font-size: 12px;
        color: #EC6C11;
    }
    
    .contain {
        padding: 0 30px 30px 30px;
        margin-top: 60px;
    }
    
    .childtitle {
        margin: 10px 0;
        font-size: 20px;
        color: #E01324;
    }
    
    .importanCon {
        font-size: 20px;
        font-weight: bolder;
        color: #E01324;
    }
    
    .markdiv {
        font-size: 14px;
        font-weight: bolder;
        color: green;
    }
    
    .spandescript {
        font-size: 16px;
    }
    </style>
</head>

<body>
    <header>
        <nav class="nav-collapse">
            <ul>
                <li class="active"><a href="#闭包" data-scroll>闭包</a></li>
                <li><a href="#作用域" data-scroll>作用域</a></li>
                <li><a href="#ECMAScript" data-scroll>ECMAScript</a></li>
                <li><a href="#Flux" data-scroll>Flux</a></li>
                <li><a href="#FluxDOM" data-scroll>Flux的DOM操作</a></li>
            </ul>
        </nav>
    </header>
    <div class="contain">
        <h1 id="闭包">闭包</h1>
        <div class="markdiv">//拿到本不该属于你的东西，容易造成内存泄漏</div>
        <pre>
        function a() {
            console.info("a");
            var i = 0;

            function b() {
                console.info("b");
                console.info(++i);
            }
            return b;
        }
        var c = a();
        </pre>
        <div class="childtitle">这段代码有两个特点：</div>
        <div>
            1、函数b嵌套在函数a内部；
            <br/>2、函数a返回函数b。 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)这段代码其实就创建了一个闭包，为什么？
            <br/> 因为函数a外的变量c引用了函数a内的函数b，就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。
        </div>
        <div class="childtitle">闭包的应用场景</div>
        <div>
            1、保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。
            <br/> 2、在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。
            <br/> 以上两点是闭包最基本的应用场景，很多经典案例都源于此。
        </div>
        <div class="childtitle">理解闭包的关键</div>
        <div>
            这种即使离开函数作用域的情况下仍然能够通过引用调用内部函数的事实，意味着<span class="importanCon">只要存在调用内部函数的可能，JavaScript就需要保留被引用的函数。而且JavaScript运行时需要跟踪引用这个内部函数的所有变量，直到最后一个变量废弃，JavaScript的垃圾收集器才能释放相应的内存空间。</span>
        </div>
        <br>更详细的内容请参考<a href="http://www.cnblogs.com/dolphinX/archive/2012/09/29/2708763.html">闭包究竟是什么</a>
        <h1 id="作用域">作用域</h1>
        <div class="markdiv">//js是函数基本作用域，在内部的变量，内部都能访问，外部不能访问内部的，内部能访问外部的</div>
        <pre>
             function test(){
                if(false){
                    var i = 10;
                }
                console.log(i);
             }
             test();<span>//undefined</span>
         </pre>
        <div></div>
        <h1 id="多重prototype链">多重prototype链</h1>
        <pre>
            // 多重prototype链的例子
            function Employee(name) {
                this.name = "name";
                this.dept = "general";
                this.gender = "unknown";
            }

            function WorkerBee() {
                this.projects = [];
                this.hasCar = false;
            }

            function Engineer() {
                this.dept = "engineer";<span>//覆盖了 "父对象"</span>
                this.language = "javascript";
            }

            WorkerBee.prototype = new Employee;<span>// 第一层prototype链</span>
            console.info(WorkerBee);
            Engineer.prototype = new WorkerBee;<span>// 第二层prototype链</span>
            console.info(Engineer);
            var jay = new Engineer("Jay");
            console.info(jay);
            console.info("dept ", jay.dept);<span>//engineer, 找到的是自己的属性</span>
            console.info("hasCar ", jay.hasCar);<span>// false, 搜索到的是自己上一层的属性</span>
            console.info("gender ", jay.gender);<span>// unknown, 搜索到的是自己上二层的属性</span>
        </pre>
        <div>看得到的jay对象如下</div>
        <img src="img/prototype.png" alt="">
        <h1 id="ECMAScript">有趣的ECMAScript </h1>
        <div class="childtitle">slice()</div>
        <pre>
            var phoneid = "id=235689147jjj";
            console.log(phoneid.slice("3"));<span>//235689147jjj  从第三个开始到最后</span>
            console.log(phoneid.slice("3", "-1"));<span>//235689147jj 从第三个开始，到倒数第二个（后面的-1.相当于phoneid总长度与-1之和）</span>
            console.log(phoneid.substring("3"));<span>//235689147jjj  从第三个开始到最后</span>
            console.log(phoneid.substring("3", "0"));<span>//id=  从第一个到第三个</span>
            console.log(phoneid.substring("3", "-1"));<span>//id= 从第一个到第三个，后面的-1.会自动变为0，而且substring始终把小的数字放前面</span>
        </pre>
        <div class="childtitle">差不多parseInt()</div>
        <pre>
            var  n1 = "12";
            console.log(typeof n1);<span>//string 原来n1为字符串</span>
            n1 =  + n1;
            console.log(typeof n1);<span>//number 使用了后变为数字了，相当于parseInt() </span>
            console.log(n1);<span>//12</span>
            n1 =  - n1;
            console.log(n1);<span>//-12 还可以把数字变为负数</span>
            n2 = 1 + n1;
            console.log(n2);<span>//-11 直接与数字计算</span>
        </pre>
        <div class="childtitle">lastIndexOf()</div>
        <pre>
            var t1 = "hellosdfsdfsfo";
            console.log(t1.indexOf("o"));<span>//4 从前往后数</span>
            console.log(t1.lastIndexOf("o"));<span>//13 从后往前数</span>
        </pre>
        <div class="childtitle">ECMAScript 标签语句</div>
        <pre>
            var iNum = 0;
            outermost:
                for (var i = 0; i < 10; i++) {
                    for (var j = 0; j < 10; j++) {
                        if (i == 5 && j == 5) {
                            // continue outermost;<span>//95 i和j都为5时候，跳出这个for到标签outermost，位置，继续执行for循环</span>
                            break outermost; <span>//55 i和j都为5时候，跳出到标签outermost，位置，且直接退出</span>
                        }
                        iNum++;
                    }
                }
            console.log(iNum); 
        </pre>
        <div class="childtitle">arguments[0], 获取未知个数的参数</div>
        <pre>
            <span>//无需明确命名参数,可以接受任意个数的参数（根据 Netscape 的文档，最多可接受 255 个）</span>
            function fcname(){
                console.info(arguments.length);
                console.info(arguments[0],arguments[1],arguments[2]);
            } 
            fcname(13,34,89,44,35,67);
        </pre>
        <div class="childtitle">原型和构造函数的问题</div>
        <pre>
            function Car(sColor,iDoors,iMpg) {
              this.color = sColor;
              this.doors = iDoors;
              this.mpg = iMpg;
              this.showColor = function() {
                alert(this.color);
              };
            }

            var oCar1 = new Car("red",4,23);
            var oCar2 = new Car("blue",3,25);
        </pre>
        <div class="markdiv">//注释: 上面的例子中，是通过构造函数来穿甲showCar熟悉，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。
            <br>所以，我们引入原型链的概念</div>
        <pre>
            <span>//但是原型链也有问题，如：给一个初始化的实例赋值，会影响另一个实例的内容</span>
            function Car(color) {
                console.info("init Car");
                this.color = color;
                Car.prototype.doors = 4;
                Car.prototype.mpg = 25;
                Car.prototype.showColor = function() {
                    console.info("showCar ",this.color);
                };
            }
            var oCar2 = new Car();
            var oCar1 = new Car("blue");
            console.info(oCar1.showColor());<span>//输出 "showCar blue"</span>
            console.info(oCar2.showColor());<span>//输出 "showCar blue"</span>          


            <span>//所以，我们结合原型链和构造函数，以下是构造函数与原型链结合起来使用，正常</span>
            function Car(sColor,iDoors,iMpg) {
              this.color = sColor;
              this.doors = iDoors;
              this.mpg = iMpg;
              this.drivers = new Array("Mike","John");
            }
            Car.prototype.showColor = function() {
              console.info(this.color);
            };
            var oCar1 = new Car("red",4,23);
            var oCar2 = new Car("blue",3,25);
            oCar1.drivers.push("Bill");
            console.info(oCar1.drivers);<span>//输出 "Mike,John,Bill"</span>
            console.info(oCar2.drivers);<span>//输出 "Mike,John"</span>
        </pre>
        <br>
        <h1 id="Flux">Flux</h1>
        <div class="childtitle">Flux是什么，和React区别</div>
        <br>
        <span class="spandescript">1. Flux不是一个具体的框架，而是facebook提出的一种代码架构</span>
        <br>
        <span class="spandescript">2. React只是一个视图库，Flux是咋React的基础上对前端整体的组织方案</span>
        <br>
        <span class="spandescript">3. 传统的MVC只适用与中小型的系统，对大规模系统来说MVC复杂度过高</span>
        <br>
        <span class="spandescript">4. Flux的目的是保证逻辑清晰，数据流向清晰，依赖关系清晰</span>
        <br>
        <br>
        <h1 id="FluxDOM">操作DOM元素</h1>
        <div class="childtitle">可以实时刷新dom内容，也可以获取dom后整体刷新</div>
        <br>
        <pre>
            <span>//通过this.getDOMNode()获取当前dom，并修改</span>
            console.info("_save "+this.getDOMNode().value);
            this.props.onSave(this.getDOMNode().value);
            this.getDOMNode().value = "";

            <span>-------------------------------------奇怪的分割线-------------------------------------------</span>

            <span>//通过修改state来实时刷新</span>
            onBlur={this._save}
            onChange={this._onChange}<span>//绑定onchange事件</span>
            value={this.state.value}<span>//更新当前的值</span>

            <span>//一旦change就setState，当keyDown就刷新state的value，一旦onBlur失去焦点，就保存当前是数据</span>
              _save: function() {
                this.props.onSave(this.state.value);
                this.setState({
                  value: ''
                });
              },
              _onChange: function(/*object*/ event) {
                this.setState({
                  value: event.target.value
                });
              },

              _onKeyDown: function(event) {
                if (event.keyCode === ENTER_KEY_CODE) {
                  this._save();
                }

            <span>-------------------------------------奇怪的分割线-------------------------------------------</span>

            <span>//或者通过refs来获取虚拟dom，input中添加ref属性,然后通过this.refs.input.getDOMNode()来获取此属性</span>
              < input
                className={this.props.className}
                id={this.props.id}
                placeholder={this.props.placeholder}
                onBlur={this._save}
                ref="inputs"
                // onChange={this._onChange}
                onKeyDown={this._onKeyDown}
                // value={this.state.value}
                autoFocus={true}
              />

              var str = this.refs.input.getDOMNode().value;
        </pre>
    </div>
    <script src="js/responsive-nav.js"></script>
    <script src="js/fastclick.js"></script>
    <script src="js/scroll.js"></script>
    <script src="js/fixed-responsive-nav.js"></script>
</body>

</html>
